# Development Workflow for Hot Reload with Persistent Daemon

This document describes the recommended workflow for frontend development with hot reload while keeping terminal sessions alive.

## Quick Start

### Two-Terminal Development Workflow

**Terminal 1 - Interactive Daemon Monitor:**
```bash
pnpm run daemon:dev
```

This gives you a **live monitoring dashboard** showing:
- ‚úÖ Daemon status (running/stopped)
- ‚è± Uptime counter
- üîå Active connections
- üìü Terminal count
- ‚ö†Ô∏è Errors and warnings
- üé® Color-coded logs (errors=red, warnings=yellow, info=green)
- üîÑ Real-time activity stream

**Terminal 2 - Tauri Dev Mode:**
```bash
pnpm run tauri:dev
```

This gives you hot reload for:
- TypeScript changes (`src/**/*.ts`)
- CSS changes (`src/style.css`)
- HTML changes (`index.html`)

**Why this workflow is great:**
- See daemon activity in real-time
- Catch errors immediately
- Monitor connection health
- Watch terminal lifecycle events
- Easy debugging with live logs
- Ctrl+C in Terminal 1 cleanly stops daemon
- Frontend hot-reloads preserve daemon state

## Workflow

### 1. Initial Connection
1. Start the daemon (Terminal 1)
2. Start the Tauri app (Terminal 2)
3. Select a workspace
4. Create some terminals or let it create defaults

At this point:
- Frontend has xterm.js instances connected to terminals
- OutputPoller is polling each terminal for updates
- Daemon has tmux sessions for each terminal

### 2. Frontend Hot Reload
When you save a frontend file (TS/CSS/HTML):

**What happens automatically:**
- Vite detects the change and rebuilds
- Browser/webview reloads
- App state resets (terminal IDs, xterm instances lost)
- Daemon **stays running** with all tmux sessions intact

**What you need to do:**
1. App will auto-reload your workspace (if stored)
2. It will attempt to reconnect terminals automatically
3. If reconnection fails or looks wrong:
   - Go to **Help ‚Üí Daemon Status...**
   - Click **Yes** when asked "Would you like to reconnect terminals?"
   - This will:
     - Query daemon for active terminals
     - Match them to your config
     - Recreate xterm.js instances
     - Restart output polling

### 3. Verifying Connection

After hot reload or manual reconnection:

**Good signs:**
- Primary terminal shows content
- You can type in the terminal
- Mini terminal cards show correct status
- No error states on terminals

**Bad signs:**
- Terminals show "Missing Session" error
- No output when you type
- Console shows "No response" errors

**If you see bad signs:**
1. Check daemon is running (Terminal 1 should have output)
2. Try manual reconnection: **Help ‚Üí Daemon Status... ‚Üí Yes**
3. If still broken, restart daemon (Ctrl+C in Terminal 1, then restart)

## Common Scenarios

### Scenario A: Quick CSS Tweak
```
1. Edit src/style.css
2. Save (Cmd+S)
3. App hot-reloads automatically
4. Terminals reconnect automatically
5. Continue working
```

### Scenario B: TypeScript Refactoring
```
1. Edit src/lib/ui.ts
2. Save (Cmd+S)
3. App hot-reloads automatically
4. If terminals look disconnected:
   - Help ‚Üí Daemon Status... ‚Üí Yes
5. Verify primary terminal works
6. Continue editing
```

### Scenario C: Daemon Gets Into Bad State
```
1. Terminals showing errors
2. Reconnection doesn't help
3. Solution:
   - Ctrl+C in Terminal 1 (daemon)
   - Restart daemon
   - Help ‚Üí Daemon Status... ‚Üí Yes
   - Should be clean now
```

### Scenario D: Want Fresh Start
```
1. Close workspace: File ‚Üí Close Workspace
2. Ctrl+C daemon (Terminal 1)
3. Clear old sessions: tmux kill-server
4. Restart daemon
5. Restart Tauri app (Terminal 2)
6. Select workspace
7. Fresh terminals created
```

## Technical Details

### What Gets Preserved Across Hot Reload
- ‚úÖ Daemon process (runs independently)
- ‚úÖ Terminal tmux sessions (in daemon)
- ‚úÖ Terminal history/scrollback (in tmux)
- ‚úÖ Terminal IDs (stable, generated by daemon)
- ‚úÖ Workspace selection (stored in Tauri state)
- ‚úÖ Config file (`.loom/config.json` on disk)

### What Gets Reset on Hot Reload
- ‚ùå Frontend JavaScript state
- ‚ùå xterm.js instances (in-memory)
- ‚ùå OutputPoller state (needs restart)
- ‚ùå Event listeners (re-attached on render)

### How Reconnection Works
1. `initializeApp()` runs on startup
2. Loads stored workspace path
3. Validates it's still a git repo
4. Calls `handleWorkspacePathInput()`
5. Loads config from `.loom/config.json`
6. Calls `reconnectTerminals()`
7. Queries daemon: `list_terminals`
8. For each terminal in config:
   - If found in daemon: reconnect
   - If missing: mark as error
9. Creates xterm.js for primary terminal
10. Starts output polling

## Debugging Tips

### Check Daemon Health
```bash
# See if daemon process is running
ps aux | grep loom-daemon

# Check socket exists
ls -la ~/.loom/daemon.sock

# Test daemon responds to ping
# (You'll need to manually send JSON via socat or nc)
```

### Console Logging
Open DevTools (Cmd+Option+I) and watch for:
```
[reconnectTerminals] Querying daemon for active terminals...
[reconnectTerminals] Found X active daemon terminals
[reconnectTerminals] Config has Y agents
[reconnectTerminals] Reconnecting agent <name> (<id>)
[reconnectTerminals] Reconnection complete: X reconnected, Y missing
```

### Check tmux Sessions
```bash
# List all tmux sessions (these are your terminals)
tmux ls

# Attach to a session manually to see its content
tmux attach -t loom-<id>

# Kill all sessions (nuclear option)
tmux kill-server
```

## Performance Notes

### Hot Reload Speed
- TypeScript changes: ~1-2 seconds
- CSS changes: ~500ms
- Vite is optimized for fast rebuilds

### Reconnection Overhead
- Querying daemon: ~10ms
- Creating xterm.js instance: ~50ms
- Fetching terminal history: ~100ms (depends on scrollback size)
- Total: < 200ms for typical case

### When to Restart Daemon
You should restart the daemon if:
- Memory usage looks high (daemon has a memory leak)
- Terminals are behaving weirdly (corrupted state)
- You changed daemon code (need new binary)
- You want a completely fresh start

You don't need to restart if:
- Just doing frontend changes (CSS/TS/HTML)
- Terminals are working fine
- Just did a hot reload

## Available Commands

### Development
- `pnpm run daemon:dev` - **Interactive daemon monitor** (Terminal 1)
- `pnpm run tauri:dev` - **Tauri dev mode** (Terminal 2)

### Building
- `pnpm run build` - Build frontend (TypeScript + Vite)
- `pnpm run tauri:build` - Build production app (Tauri + daemon)
- `pnpm run daemon:build` - Build daemon binary only

### Testing
- `pnpm run daemon:test` - Run daemon integration tests
- `pnpm run check` - Check workspace compilation

### Code Quality
- `pnpm run check:all` - Run all checks (lint, format, clippy, build)
- `pnpm run lint` - Check frontend code style
- `pnpm run lint:fix` - Auto-fix frontend linting issues
- `pnpm run format:write` - Auto-format frontend code
- `pnpm run format:rust:write` - Auto-format Rust code
- `pnpm run clippy` - Run Rust linter
- `pnpm run clippy:fix` - Auto-fix Rust linting issues

## Future Improvements

Potential enhancements to this workflow:

1. ‚úÖ **Simplified dev workflow**: Single command to start everything (DONE: `pnpm run app:dev`)
2. ‚úÖ **Easy daemon restart**: Quick command to restart daemon (DONE: `pnpm run app:dev:restart`)
3. **Smarter reconnection**: Detect hot reload and reconnect automatically without user action
4. **Connection health indicator**: Show connection status in UI (green = connected, red = disconnected)
5. **Reconnect on terminal switch**: Auto-reconnect when switching primary terminal if connection lost
6. **Daemon restart without tmux loss**: Save tmux session state to disk so daemon restart preserves terminals
